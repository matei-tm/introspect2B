name: Deploy API Gateway

on:
    workflow_dispatch:
        inputs:
            service_endpoint:
                description: "Optional: NLB/ALB DNS name for claim-status-api (no scheme). If omitted, it will be auto-discovered."
                required: false
            environment_name:
                description: "API Gateway stage name"
                required: true
                type: choice
                options:
                    - dev
                    - staging
                    - prod
                default: dev
            aws_region:
                description: "AWS region"
                required: true
                default: us-east-1
            eks_cluster_name:
                description: "Optional: EKS cluster name to query Service via kubectl"
                required: false
            k8s_namespace:
                description: "Optional: Kubernetes namespace for the Service"
                required: false
                default: materclaims
            k8s_service_name:
                description: "Optional: Kubernetes Service name"
                required: false
                default: claim-status-api
            lb_name:
                description: "Optional: ELBv2 Load Balancer name (fallback if kubectl not used)"
                required: false
                default: claim-status-api
            assume_role_arn:
                description: "Optional IAM Role ARN to assume via OIDC"
                required: false

jobs:
    deploy:
        name: Deploy APIGW Stack
        runs-on: ubuntu-latest
        permissions:
            id-token: write # for OIDC
            contents: read

        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Discover Service Endpoint (kubectl/ELBv2)
              env:
                    AWS_REGION: ${{ inputs.aws_region }}
              run: |
                    set -e
                    # If provided explicitly, use it
                    if [ -n "${{ inputs.service_endpoint }}" ]; then
                        echo "SERVICE_ENDPOINT=${{ inputs.service_endpoint }}" >> "$GITHUB_ENV"
                        echo "Using provided service endpoint: ${{ inputs.service_endpoint }}"
                        exit 0
                    fi

                    # Try kubectl if cluster name provided
                    if [ -n "${{ inputs.eks_cluster_name }}" ]; then
                        echo "Attempting kubectl discovery from EKS cluster: ${{ inputs.eks_cluster_name }}"
                        aws eks update-kubeconfig --name "${{ inputs.eks_cluster_name }}" --region "$AWS_REGION"
                        HOSTNAME=$(kubectl -n "${{ inputs.k8s_namespace }}" get svc "${{ inputs.k8s_service_name }}" -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
                        if [ -n "$HOSTNAME" ]; then
                            echo "SERVICE_ENDPOINT=$HOSTNAME" >> "$GITHUB_ENV"
                            echo "Discovered via kubectl: $HOSTNAME"
                            exit 0
                        else
                            echo "kubectl discovery returned empty hostname; will try ELBv2 fallback."
                        fi
                    fi

                    # Fallback: ELBv2 by name (requires aws-load-balancer-name annotation)
                    echo "Attempting ELBv2 discovery for LB name: ${{ inputs.lb_name }}"
                    HOSTNAME=$(aws elbv2 describe-load-balancers --names "${{ inputs.lb_name }}" --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || true)
                    if [ -n "$HOSTNAME" ] && [ "$HOSTNAME" != "None" ]; then
                        echo "SERVICE_ENDPOINT=$HOSTNAME" >> "$GITHUB_ENV"
                        echo "Discovered via ELBv2: $HOSTNAME"
                        exit 0
                    fi

                    echo "Failed to auto-discover Service endpoint. Provide inputs.service_endpoint or eks_cluster_name/k8s_* or lb_name."
                    exit 1

            - name: Configure AWS (OIDC role)
              if: ${{ inputs.assume_role_arn != '' }}
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  role-to-assume: ${{ inputs.assume_role_arn }}
                  aws-region: ${{ inputs.aws_region }}

            - name: Configure AWS (static keys)
              if: ${{ inputs.assume_role_arn == '' }}
              uses: aws-actions/configure-aws-credentials@v4
              with:
                  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                  aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
                  aws-region: ${{ inputs.aws_region }}

            - name: Verify AWS CLI
              run: |
                  aws --version

            - name: Deploy CloudFormation stack
              env:
                  SERVICE_ENDPOINT: ${{ env.SERVICE_ENDPOINT }}
                  ENVIRONMENT_NAME: ${{ inputs.environment_name }}
                  AWS_REGION: ${{ inputs.aws_region }}
              run: |
                  set -e
                  aws cloudformation deploy \
                      --stack-name claim-status-api-apigw \
                      --template-file apigw/api-gateway-template.yaml \
                      --parameter-overrides ServiceEndpoint="$SERVICE_ENDPOINT" EnvironmentName="$ENVIRONMENT_NAME" DeploymentVersion="${{ github.run_id }}" \
                      --no-fail-on-empty-changeset

            - id: outputs
              name: Collect stack outputs
              env:
                  ENVIRONMENT_NAME: ${{ inputs.environment_name }}
              run: |
                  set -e
                  API_ID=$(aws cloudformation describe-stacks --stack-name claim-status-api-apigw \
                      --query "Stacks[0].Outputs[?OutputKey=='ApiId'].OutputValue" --output text)
                  API_ENDPOINT=$(aws cloudformation describe-stacks --stack-name claim-status-api-apigw \
                      --query "Stacks[0].Outputs[?OutputKey=='ApiEndpoint'].OutputValue" --output text)
                  echo "api_id=$API_ID" >> "$GITHUB_OUTPUT"
                  echo "api_endpoint=$API_ENDPOINT" >> "$GITHUB_OUTPUT"
                  {
                      echo "### API Gateway Deployment"
                      echo "- Environment: $ENVIRONMENT_NAME"
                      echo "- API ID: $API_ID"
                      echo "- Public Endpoint: $API_ENDPOINT"
                      echo
                      echo "#### Quick Test"
                      echo "\nGET:"
                      echo "curl -sS \"$API_ENDPOINT/api/claims/CLAIM-001\""
                      echo "\nPOST:"
                      echo "curl -sS -X POST -H 'Content-Type: application/json' -d '{\"notesOverride\":\"Example override\"}' \"$API_ENDPOINT/api/claims/CLAIM-001/summarize\""
                  } >> "$GITHUB_STEP_SUMMARY"

        outputs:
            api_id: ${{ steps.outputs.outputs.api_id }}
            api_endpoint: ${{ steps.outputs.outputs.api_endpoint }}
